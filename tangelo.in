#!${PYTHON_EXECUTABLE}

import argparse
import os
import platform
import signal
import subprocess
import sys
import time

def start():
    sys.stderr.write("starting tangelo...")
    if os.path.exists(pidfile):
        sys.stderr.write("failed (already seems to be running)\n")
        return 1

    if daemonize:
        screen = open(os.devnull)
    else:
        screen = None

    os.chdir(path)
    args = [sys.executable, cherry,
        "-i", "tangelo",
        "-c", "server.conf",
        "-P", path]
    if daemonize:
        args += ["-d", "-p", pidfile]

    if not daemonize:
        sys.stderr.write("\n")

    retval = subprocess.call(args, stdout=screen, stderr=screen)

    if daemonize:
        f = open(logfile)
        f.seek(0, 2)
        done = False
        while not done:
            time.sleep(1)
            cur_pos = f.tell()
            line = f.readline()
            if not line:
                f.seek(cur_pos)
            else:
                if "Bus STARTED" in line:
                    retval = 0
                    sys.stderr.write("success (serving on %s)\n" % location)
                    done = True
                elif "Error" in line:
                    retval = 1
                    sys.stderr.write("failed (check tangelo.log for reason)\n")
                    done = True
                elif "Serving on" in line:
                    location = line.split("Serving on")[1].strip()

    return retval

def stop():
    retval = 0
    sys.stderr.write("stopping tangelo...")

    if os.path.exists(pidfile):
        f = open(pidfile)

        try:
            pid = int(f.read())
        except ValueError:
            if report:
                sys.stderr.write("failed (tangelo.pid does not contain a valid process id)\n")
            return 1

        try:
            os.kill(pid, signal.SIGKILL)
            os.remove(pidfile)
        except OSError:
            sys.stderr.write("failed (could not kill process %d)\n" % (pid))
            retval = 1

    if retval == 0:
        sys.stderr.write("success\n")

    return retval

def restart():
    stopval = stop()
    if stopval == 0:
        return start()
    else:
        return stopval

p = argparse.ArgumentParser(description="Control execution of a Tangelo server.")
p.add_argument("-d", "--no-daemon", action="store_true", help="run Tangelo in-console (not as a daemon).")
#p.add_argument("-a", "--no-auth", action="store_true", help="disable HTTP authentication (i.e. processing of .htaccess files).")
p.add_argument("action", metavar="<start|stop|restart>", help="perform this action for the current Tangelo instance.")
args = p.parse_args()

no_daemon = args.no_daemon
#do_auth = not args.no_auth
action = args.action

# Configured variables.
cherry = "@CherryPy_EXECUTABLE@"

# Detect operating system (and OSX version, if applicable).
os_name = platform.system()
if os_name == "Darwin":
    version = map(int, platform.mac_ver()[0].split("."))

# Decide whether to daemonize, based on whether the user wishes not to, and
# whether the platform supports it.
daemonize = not no_daemon and not(os_name == "Windows" or (os_name == "Darwin" and version[1] == 6))

# Determine the path to this script.
path = os.path.dirname(os.path.abspath(sys.argv[0]))
pidfile = path + "/tangelo.pid"
logfile = path + "/tangelo.log"

# Dispatch on action argument.
code = 1
if action == "start":
    code = start()
elif action == "stop":
    if not daemonize:
        sys.stderr.write("error: stop action not supported on this platform\n")
        sys.exit(1)
    code = stop()
elif action == "restart":
    if not daemonize:
        sys.stderr.write("error: restart action not supported on this platform\n")
        sys.exit(1)
    code = restart()
else:
    p.print_usage()
    code = 1

sys.exit(code)
