import cherrypy
import grp
import imp
import json
import pwd
import StringIO
import sys
import traceback
import types

from cherrypy.lib.static import serve_file
from cherrypy.process.plugins import DropPrivileges

# This function defines the structure of a service response.  Each service
# module should import this function from this package.
#
# The payload is contained in the 'result' field, while the 'error' field can
# indicate that something went wrong.  Posibly more fields could be added in the
# future.
def empty_response():
    return {'result' : None,
            'error' : None}

def content_type(t=None):
    r = cherrypy.response.headers['Content-type']

    if t is not None:
        cherrypy.response.headers['Content-type'] = t

    return r

def log(msg):
    cherrypy.log(msg)

# 'current_dir' is used by the CherryPy config file to set the root for static
# file service.
import os.path
current_dir = os.path.dirname(os.path.abspath(__file__))

# If we are the superuser, try to drop privileges (since we've bound to whatever
# port superuser privileges were needed for already).
if os.getuid() == 0:
    # Set the username and groupname to drop privileges down to.
    user = "@SERVER_USER@"
    group = "@SERVER_GROUP@"

    # If we're on windows, don't supply any username/groupname.
    if user == "windows" and group == "windows":
        DropPrivileges(cherrypy.engine).subscribe()
    else:
        try:
            uid = pwd.getpwnam(user).pw_uid
        except KeyError:
            log("error: no such user '%s' to drop privileges to" % (user))
            sys.exit(1)

        try:
            gid = grp.getgrnam(group).gr_gid
        except KeyError:
            log("error: no such group '%s' to drop privileges to" % (group))
            sys.exit(1)

        DropPrivileges(cherrypy.engine, uid=uid, gid=gid).subscribe()

userpassdict = {"alice": "swatter"}
get_ha1 = cherrypy.lib.auth_digest.get_ha1_dict_plain(userpassdict)
digest_auth = {"tools.auth_digest.on": True,
               "tools.auth_digest.realm": "wonderland",
               "tools.auth_digest.get_ha1": get_ha1,
               "tools.auth_digest.key": "deadbeef"}

def invoke_service(module, *pargs, **kwargs):
    # TODO(choudhury): This method should attempt to load the named module, then invoke it
    # with the given arguments.  However, if the named module is "config" or
    # something similar, the method should instead launch a special "config"
    # app, which lists the available app modules, along with docstrings or
    # similar.  It should also allow the user to add/delete search paths for
    # other modules.
    content_type("text/plain")

    # Construct a response container for reporting possible errors, as the
    # service modules themselves do.
    response = empty_response()

    # Import the module.
    try:
        service = imp.load_source("service", module)
    except IOError as e:
        log("error: " + module)
        response['error'] = "IOError: %s" % (e)
        return json.dumps(response)

    # Report an error if the Handler object has no go() method.
    if 'run' not in dir(service):
        response['error'] = "tangelo: error: no function `run()` defined in module '%s'" % (module)
        return json.dumps(response)

    # Call the module's run() method, passing it the positional and keyword args
    # that came into this method.
    try:
        result = service.run(*pargs, **kwargs)

        # Check the type of the result - if it's anything other than a string,
        # assume it needs to be converted to JSON.
        #
        # This allows the services to return a Python object if they wish, or to
        # perform custom serialization (such as for MongoDB results, etc.).
        if not isinstance(result, types.StringTypes):
            result = json.dumps(result)

        return result
    except Exception as e:
        # Error message.
        response['error'] = "tangelo: error: %s: %s" % (e.__class__.__name__, e.message)

        log("Caught exception - %s: %s" % (e.__class__.__name__, e.message))

        # Full Python traceback stack.
        s = StringIO.StringIO()
        traceback.print_exc(file=s)
        if 'traceback' in response:
            response['traceback'] += "\n" + s.getvalue()
        else:
            response['traceback'] = "\n" + s.getvalue()

        # Serialize to JSON.
        return json.dumps(response)

class HtAccess:
    def __init__(self, filename):
        try:
            self.f = open(filename)
        except IOError:
            self.f = None
        else:
            # TODO(choudhury): Parse the file and store the contents in class
            # members.
            pass

    def __nonzero__(self):
        return self.f is not None

class Server(object):
    def __init__(self):
        self.app = None
        self.security = {}

    def htaccess(self, htfile, path_info):
        # TODO(choudhury): look at
        # /usr/lib/python2.7/site-packages/cherrypy/lib/auth_digest.py and
        # /usr/lib/python2.7/site-packages/cherrypy/test/test_auth_digest.py for
        # examples of how to do digest auth.  Will want to have users use a
        # tangpass sort of script to generate .htaccess files, so the digest
        # method can remain consistent.
        #
        # May also want to include a basic auth path as well, perhaps depending
        # on a key/value in the .htaccess file itself.

        # If there is no htfile, then ensure that the path is unregistered from
        # the security dict, and unregister the config found there.  Otherwise,
        # parse the htfile and add whatever is found there to the security
        # registry and the application configuration.
        if htfile is None:
            if path_info in self.security:
                cherrypy.log("Removing security path %s" % (path_info))
                del self.security[path_info]
                self.app.pop(path_info, None)
        else:
            if path_info[-1] != "/":
                path_info = "/".join(path_info.split("/")[:-1])
            cherrypy.log("Registering %s..." % (path_info))

            # Stat the file specifically to learn it's last-modified time.
            htinfo = os.stat(htfile)

            if path_info not in self.security or htinfo.st_mtime > self.security[path_info]:
                # We have found an htaccess file - if there is NO ENTRY in the
                # security table, OR there IS an entry but the htaccess file is
                # NEWER than the one used to create that entry, then we need to
                # parse the file and insert (or update) the record in the table.
                htspec = HtAccess(htfile)

                # TODO(choudhury): This simply installs a basic testing auth.
                # Need to (1) parse the .htaccess file and (2) install the right
                # config on the application.
                c = {path_info: digest_auth}
                self.app.merge(c)

                # Store the htfile's last-modified time.
                self.security[path_info] = htinfo.st_mtime

                cherrypy.log("Added %s to registry!" % (path_info))
            else:
                cherrypy.log("%s already registered!" % (path_info))

    @cherrypy.expose
    def default(self, *path, **args):
        if self.app is None:
            self.app = cherrypy.tree.apps.values()[0]

        # Convert the path argument into a list (from a tuple).
        path = list(path)

        # If there are no positional arguments, behave as though the root
        # index.html was requested.
        if len(path) == 0:
            path = ["index.html"]

        # Check the first character of the first path component.  If it's a
        # tilde, then assume the path points into a user's home directory.
        if path[0][0] == "~":
            # Only treat this component as a home directory if there is actually
            # text following the tilde (rather than making the server serve
            # files from the home directory of whatever user account it is using
            # to run).
            if len(path[0]) > 1:
                # Expand the home directory, append the tangelo_html
                # subdirectory, and then the tail of the original path.
                path = os.path.expanduser(path[0]).split("/") + ["tangelo_html"] + path[1:]
        else:
            # TODO(choudhury): check a table of configured custom mappings to
            # see if the first path component should be mapped to some other
            # filesystem path.

            # Reaching this point means the path is relative to the server's web
            # root.
            path = current_dir.split("/") + ["web"] + path

        # Check for the word "service" in the path - this indicates the
        # invocation of a web service placed somewhere besides the global
        # services list.
        try:
            service = path.index("service")

            # Make sure there is an actual service name after the "service" path
            # component.
            if len(path) == service + 1:
                raise cherrypy.HTTPError(404, "Did you forget the service name?")

            # Grab the portion of the path that names the service (appending the
            # standard python file extension as well).
            service_path = "/".join(path[:(service+2)]) + ".py"

            # Grab the rest of the path list, as the positional arguments for
            # the service invocation.
            pargs = path[(service+2):]

            # Invoke the service and return the result.
            return invoke_service(service_path, *pargs, **args)
        except ValueError:
            pass

        # Form a path name from the path components.
        finalpath = "/".join(path)

        # If the path represents a directory, first check if the URL is missing
        # a trailing slash - if it is, redirect to a URL with the slash
        # appended; otherwise, append "index.html" to the path spec and
        # continue.
        if os.path.isdir(finalpath):
            if cherrypy.request.path_info[-1] != "/":
                raise cherrypy.HTTPRedirect(cherrypy.request.path_info + "/")
            else:
                finalpath += "/index.html"

        # If the home directory expansion above failed (or something else went
        # wrong), then the filepath will not be an absolute path, and we bail.
        if not os.path.isabs(finalpath):
            raise cherrypy.HTTPError(404)

        # Check to see whether the path is protected by an .htaccess file.
        htfile = os.path.dirname(finalpath) + "/.htaccess"
        if not os.path.exists(htfile):
            htfile = None
        self.htaccess(htfile, cherrypy.request.path_info)

        # Serve the file.
        return serve_file(finalpath)
