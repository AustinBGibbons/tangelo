<!DOCTYPE html>
<meta charset="utf-8">
<title>Cross-Cat Animation</title>
<link rel=stylesheet type=text/css href=/bootstrap.css>
<link rel=stylesheet type=text/css href=/bootstrap-xdata.css>
<style>
.active {
  fill: red
}

#play:hover {
  cursor: pointer
}

</style>
<script src="http://d3js.org/d3.v2.min.js?2.8.1"></script>

<div class=container>
    <div class=masthead>
        <a href="/"><h3 class=muted>XDATA Web</h3></a>
    </div>

    <hr>

    <div class=jumbotron>
        <h1 class=title>Cross-Cat Animation</h1>

        <p class=lead>Watch a predictive database crunch the numbers</p>

        <p class=description>This demo shows an animation of the sequence of operations performed by the <a href="http://web.mit.edu/vkm/www/crosscat.pdf">Cross-Cat</a> clustering
        algorithm developed by Vikash Mansinghka et al. at MIT. This is an example of a visualization that will be possible using the Vega visualization grammar and
        the Visualization Design Environment, whose goal is to make advanced visualization apps such as this producable by non-programmers.
        This combines efforts from a DARPA XDATA TA1 analysis team (SSCI / MIT) with a TA2 visualization team (Kitware / Stanford / Georgia Tech / Harvard / U. Utah / KnowledgeVis).
        The rows of the table represent the objects (here, animal species) and the columns represent attributes.
        A Cross-Cat clustering consists of a set of views, or groups of attributes, where each object is assigned to a partition in each view.
        The number of views and the number of partitions per view are free variables that are detected dynamically based on properties of the data.</p>

        <p class=description>Hover over a row to see its corresponding location in other views.
        Press the play/pause button to start and stop the looping animation. The animation will be smoothest on the latest Google Chrome.</p>
    </div>

    <hr>

    <div class=row>
        <div class=span2 style="text-align:right;font-size:24px;">
            time step
        </div>

        <div class=span1>
            <select id="time" class=span1>
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
            </select>
        </div>

        <div class=span1>
            <!--<div id="play">❚❚</div>-->
            <a id="play" class="btn btn-success">❚❚</a>
        </div>
    </div>
</div>

<!-- Place the svg element outside of the bootstrap grid so it can float out to
     the left -->
<svg id="svg"></svg>

<script>

var playing = true;
var timeValue = "0";
var animationLength = 1000;

var margin = {top: 200, right: 800, bottom: 200, left: 150},
    width = 1500,
    height = 400;

var x = d3.scale.ordinal().rangeBands([0, width]),
    y = [d3.scale.ordinal().rangeBands([0, height])],
    z = d3.scale.linear().domain([0, 4]).clamp(true),
    c = d3.scale.category20().domain([1, 0]);

var colPartition = [];
var rowPartition = [];
var firstColumnInView = [];
var rowPartitionReindex = [];

var svg = d3.select("#svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    //.style("margin-left", -margin.left + "px")
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

svg.append("svg:defs")
  .append("svg:filter")
    .attr("id", "blur")
  .append("svg:feGaussianBlur")
    .attr("in", "SourceGraphic")
    .attr("stdDeviation", 4);

d3.json("ssci.json", function(data) {
  // The default sort order.
  x.domain(d3.range(data.columns.length));
  y[0].domain(d3.range(data.rows.length));

  svg.append("rect")
      .attr("class", "background")
      .style("fill", "white")
      .attr("width", width)
      .attr("height", height);

  var column = svg.selectAll(".column")
      .data(data.columns)
    .enter().append("g")
      .attr("class", "column")
      .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

  column.append("line")
      .attr("x1", -width);

  column.append("text")
      .attr("x", 6)
      .attr("y", x.rangeBand() / 2)
      .attr("dy", ".32em")
      .attr("text-anchor", "start")
      .text(function(d, i) { return d.name; });

  var cell = svg.selectAll(".cell")
      .data(data.table)
    .enter().append("rect")
      .attr("class", "cell")
      .attr("x", function(d) { return x(d.j); })
      .attr("y", function(d) { return y[0](d.i); })
      .attr("width", x.rangeBand())
      .attr("height", y[0].rangeBand())
      .attr("opacity", function(d) { return d.value ? 1 : 0.5; })
      .style("fill", function(d) { return c(d.value); })
      .on("mouseover", mouseover)
      .on("mouseout", mouseout)
    .append("title")
      .text(function(d) { return d.row + "," + d.col; });

  function updateRows() {
    var row = svg.selectAll(".row")
        .data(y.slice(1));
    row.enter().append("g")
        .attr("class", "row")
        .each(viewRows);
    row.each(viewRows);
    row.exit().remove();
  }

  function viewRows(y, viewIndex) {
    var col = firstColumnInView[viewIndex];

/*
    var rowTextGlow = d3.select(this).selectAll(".row-text-glow").data(data.rows);
    rowTextGlow.enter().append("text")
        .attr("class", "row-text-glow")
        .attr("x", -6)
        .attr("y", y.rangeBand() / 2)
        .attr("dy", ".32em")
        .attr("filter", "url(#blur)")
        .attr("transform", function(d, i) { return "translate(" + columnPosition(col) + "," + rowPosition(i, col) + ")"; })
        .style("fill", "white")
        .style("stroke", "white")
        .style("stroke-width", "4px")
        .attr("text-anchor", "end")
        .text(function(d, i) { return d.name; });
    rowTextGlow.style("opacity", col < 0 ? 0 : 1)
    rowTextGlow.transition().duration(animationLength)
        .delay(function(d) { return x(col) * 1; })
        .attr("transform", function(d, i) { return "translate(" + columnPosition(col) + "," + rowPosition(i, col) + ")"; });
*/
    var rowText = d3.select(this).selectAll(".row-text").data(data.rows);
    rowText.enter().append("text")
        .attr("class", "row-text")
        .attr("x", -6)
        .attr("y", y.rangeBand() / 2)
        .attr("dy", ".32em")
        .attr("transform", function(d, i) { return "translate(" + columnPosition(col) + "," + rowPosition(i, col) + ")"; })
        .attr("text-anchor", "end")
        .text(function(d, i) { return d.name; });
    rowText.style("opacity", col < 0 ? 0 : 1)
    rowText.transition().duration(animationLength)
        .delay(function(d) { return x(firstColumnInView[viewIndex]) * 1; })
        .attr("transform", function(d, i) { return "translate(" + columnPosition(col) + "," + rowPosition(i, col) + ")"; });
  }

  updateRows();

  function mouseover(p) {
    d3.selectAll(".row text.row-text").classed("active", function(d, i) { return d === data.rows[p.i]; });
    d3.selectAll(".column text").classed("active", function(d, i) { return i == p.j; });
    d3.selectAll(".cell").attr("opacity", function(d, i) { return (d.i == p.i ? 1 : 0.25) * (rowPartition[colPartition[p.j] - 1][p.i] == rowPartition[colPartition[p.j] - 1][d.i] ? 1 : 1) * (d.value ? 1 : 0.5); });
  }

  function mouseout() {
    d3.selectAll("text").classed("active", false);
    d3.selectAll(".cell").classed("active", false);
    d3.selectAll(".cell").attr("opacity", function(d) { return d.value ? 1 : 0.5; });
  }

  d3.select("#time").on("change", function() {
    order(this.value);
  });

  d3.select("#play").on("click", function() {
    playing = !playing;
    d3.select(this).text(playing ? "❚❚" : "▶");
    if (playing) {
      d3.timer(orderWrapper(""+(+timeValue+1)%12));
    }
  });

  function columnPosition(i) {
    i = Math.max(0, i);
    return (x(i) + 75*(colPartition[i]-1));
  }

  function rowPosition(i, j) {
    j = Math.max(0, j);
    var partition = rowPartition[colPartition[j] - 1][i];
    var reindex = rowPartitionReindex[colPartition[j] - 1];
    var mx = d3.max(reindex);
    return y[colPartition[j]](i) + (mx > 1 ? (100/(mx - 1))*reindex[partition] : 100);
  }

  function order(value) {
    timeValue = value;
    colPartition = data.columnPartition[value];
    rowPartition = data.rowPartition[value];

    function sortColumns(i, j) {
      if (colPartition[i] !== colPartition[j]) {
        return d3.ascending(colPartition[i], colPartition[j]);
      }
      return d3.ascending(data.columns[i].name, data.columns[j].name);
    }

    function sortRows(group) {
      return function(i, j) {
        if (rowPartition[group][i] !== rowPartition[group][j]) {
          return d3.ascending(rowPartition[group][i], rowPartition[group][j]);
        }
        return d3.ascending(data.rows[i].name, data.rows[j].name);
      }
    }

    var colPermute = d3.range(data.columns.length).sort(sortColumns);
    x.domain(colPermute);
    y = [{}];

    rowPartitionReindex = [];
    for (var group = 0; group < rowPartition.length; ++group) {
      var cy = d3.scale.ordinal().rangeBands([0, height]);
      cy.domain(d3.range(data.rows.length).sort(sortRows(group)));
      y.push(cy);
      var newIndex = 0;
      var curReindex = [0];
      for (var part = 1; part <= data.rows.length; ++part) {
        curReindex.push(newIndex);
        if (rowPartition[group].indexOf(part) >= 0) {
          ++newIndex;
        }
      }
      rowPartitionReindex.push(curReindex);
    }

    firstColumnInView = [];
    for (var i = 0; i < colPartition.length; ++i) {
      while (colPartition[colPermute[i]] > firstColumnInView.length) {
        firstColumnInView.push(colPermute[i]);
      }
    }
    while (firstColumnInView.length < rowPartition.length) {
      firstColumnInView.push(-1);
    }

    var t = svg.transition().duration(animationLength);

    updateRows();

    t.selectAll(".cell")
        .delay(function(d) { return x(d.j) * 1; })
        .attr("x", function(d) { return columnPosition(d.j); })
        .attr("y", function(d) { return rowPosition(d.i, d.j); });

    t.selectAll(".column")
        .delay(function(d, i) { return x(i) * 1; })
        .attr("transform", function(d, i) { return "translate(" + columnPosition(i) + ")rotate(-90)"; });

    if (playing) {
      d3.timer(orderWrapper(""+(+value + 1)%12), animationLength + 3000);
    }
    return true;
  }

  function orderWrapper(value) {
    return function() {
      if (!playing) {
        return true;
      }
      d3.select("#time").node().selectedIndex = +value;
      return order(value);
    }
  }

  orderWrapper("0")();
});
</script>
